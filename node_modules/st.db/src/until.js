const fs = require("fs")
const path = require("path")
const Cryptr = require(require("path").resolve(__dirname, 'encrypt/index.js'));
const cryptrr = new Cryptr('myTotalySecretKey');
const { ApiOperator } = require('./requirements.js')
const isNumber = require('is-number');

const stdb = {
  creationoptions: (options, defults) => {
    if (!options) return null;
    let configs = new Object();
    configs.debug = Boolean(options.debug);
    configs.path = options.path
    if (!configs.path) configs.path = defults.path
    return configs;
  },
  makeDB: (db) => {
       fs.access(db, fs.constants.F_OK, (err) => {
      if (err) {
        fs.writeFileSync(db, JSON.stringify({}, null, 4))
      } 
    });
  }
}
class Data {
  constructor(actions) {
    if(typeof actions == `object`){
      this.dbName = actions.path || "data"
      this.api = actions.api || false
      this.log = actions.log || false
      this.encrypt = actions.encrypt || false
    } else {
      this.dbName = actions || "data"
    }
    this.options = stdb.creationoptions(actions, {
      path: this.dbName
    })
    let basePath = process.cwd();
    if (this.dbName.startsWith(basePath)) {
      this.dbName = this.dbName.replace(basePath, "");
    }
    if (this.dbName.startsWith(`.${path.sep}`)) {
      this.dbName = this.dbName.slice(1);
    }
    if (!this.dbName.endsWith(".json")) {
      if (this.dbName.endsWith(path.sep)) {
        this.dbName += "stdb.json";
      } else {
        this.dbName += ".json";
      }
    }
    var stats = fs.statSync(`./${this.dbName}`)
    this.size = stats.size
    this.db = path.resolve(`./${this.dbName}`)
    stdb.makeDB(this.db)
    if (this.log === true) {
      console.log(`\u001b[48;5;2mST.db™\u001b[0m ▶ \u001b[38;5;2mYour ${this.dbName}.st file has been successfully accessed\u001b[0m`)
      if (this.encrypt === true) {
        console.log(`➥ \u001b[38;5;2mEncrypt: \u001b[0m${this.encrypt || 'false'}`)
      }
      console.log(`➥ \u001b[38;5;2mLogs: \u001b[0m${this.log || 'false'}`)
    }
    if (this.api === true) {
      if (this.log === true) return console.log(`\u001b[0m➥ \u001b[38;5;2mData API : \u001b[0m${this.api || 'false'}`);
      let data = this.load()
      ApiOperator(this.dbName, data)
    }
  }

  /**
   * @exemple db.set("st.db","test")
   * @param {*} data 
   * @param {*} value 
   * @returns 
   */
   set(key = String(), value) {
     if(key.map){
       value = key.toJSON().value
       key = key.toJSON().key
     }
     if(key.key && key.value){
       value = key.value
       key = key.key
     }
     if (!value) throw Error("ST.db - You must enter a value to write in the data");
     let data = this.load()
     data[key] = value
     if (this.encrypt === true) {
       if (typeof value == "boolean") return this.overwrite(data);
       let encryptedString = cryptrr.encrypt(value);
       data[key] = encryptedString
       this.overwrite(data)
       if (this.log === true) return console.log(`\u001b[38;5;2m✚ \u001b[0m"${key}":"${encryptedString}" \u001b[38;5;2mhas been added in data\u001b[0m`);
    } else {
       this.overwrite(data)
       if (this.log === true) return console.log(`\u001b[38;5;2m✚ \u001b[0m"${key}":"${value}" \u001b[38;5;2mhas been added in data\u001b[0m`);
    }
  }
  /**
   * @exemple db.encrypt("st.db")
   * @param data 
   * @returns 
   */
  encryptValue(value) {
    return cryptrr.encrypt(value);
  }
  /**
   * @exemple db.decrypt("389a474f48b7bf2c00")
   * @param data 
   * @returns 
   */
  decryptValue(value) {
    let vecrypt = cryptrr.decrypt(value);
    let numbertrue = Number(vecrypt)
    if (Number.isFinite(numbertrue) == false) {
      return vecrypt
    }
    return Number(numbertrue)
  }
  /**
   * @example db.get("st.db")
   * @param {*} key
   * @returns 
   */
  get(key = String()) {
    if(key.key){
      key = key.key
    }
    let data = this.load()
    let value = data[key]
    try {
      let Decrypt = cryptrr.decrypt(value);
      if(isNumber(Decrypt) == true){
        return +Decrypt
      } else {
        return Decrypt
      }
    } catch (error) {
      if(isNumber(value) == true){
        return +value
      } else {
        return value
      }
    }
  }
  /**
   * @example db.fetch("st.db")
   * @param {*} key
   * @returns 
   */
  fetch(key = String()) {
    if(key.key){
       key = key.key
    }
    return this.get(key)
  }
  /**
   * @example db.has(`st.db`)
   * @param  data 
   * @returns 
   */
  has(data) {
    if(data.key){
      data = data.key
    }
    if (!data) throw Error("ST.db - No data to has function");
    let fileData = this.load()
    if (!fileData[data]) return false;
    if (fileData[data]) return true;
  }
  /**
   * @example db.destroy()
   * @returns 
   */
  destroy() {
    try {
      fs.unlinkSync(`./${this.dbName}`)
    } catch (err) {
      console.log(`\u001b[48;5;160mWarning!\u001b[0m\u001b[38;5;160m The data has been destroyed before!\u001b[0m`)
    }
    return;
  }
  /**
   * @example db.all()
   * @param limit
   * @returns 
   */
  all(limit = 0) {
    if (typeof limit !== "number") {
      throw Error("Must be of limit number type!");
    }

    let arr = [];
    let v = 0;
    for (const key in this.load()) {
      arr.push({
        ID: key,
        data: this.load()[key],
        typeof: typeof this.load()[key],
        _v: v
      });
      v++;
    }
    return limit > 0 ? arr.splice(0, limit) : arr;
  }
  decryptAll(limit = 0) {
    if (typeof limit !== "number") {
      throw Error("Must be of limit number type!");
    }

    let arr = [];
    let v = 0;
    for (const key in this.load()) {
      arr.push({
        ID: key,
        data: this.get(key),
        typeof: typeof this.load()[key],
        _v: v
      });
      v++;
    }
    return limit > 0 ? arr.splice(0, limit) : arr;
  }
  /**
   * @example db.startsWith(`st.db`)
   * @param key
   * @returns 
   */
  startsWith(key) {
    if(key.key){
       key = key.key
    }
    return this.filter((element) => element.ID.startsWith(key));
  }
  /**
   * @example db.endsWith(`st.db`)
   * @param key
   * @returns 
   */
  endsWith(key) {
    if(key.key){
       key = key.key
    }
    return this.filter((element) => element.ID.endsWith(key));
  }
  /**
   * @example db.filter()
   * @param thisArg
   * @param callbackfn
   * @returns 
   */
  filter(callbackfn, thisArg) {
    if (thisArg) callbackfn = callbackfn.bind(thisArg);
    return this.all().filter(callbackfn);
  }
  /**
   * @example db.includes(`st.db`)
   * @param key
   * @returns 
   */
  includes(key) {
    if(key.key){
       key = key.key
    }
    return this.filter((element) => element.ID.includes(key));
  }
  /**
   * @example db.fetchAll()
   * @param key
   * @returns 
   */
  fetchAll() {
    return this.all()
  }

  /**
   * @example db.importFromQuickDB(quickDB)
   * @param quickDB
   * @returns 
   */
  importFromQuickDB(quickDB) {
    if (!quickDB) throw Error(`[ST.db] please write value to quick db`)
    quickDB.all().forEach(async body => {
      this.set(body.ID, quickDB.get(body.ID))
    })
    if (this.log === true) {
      console.log("\n\n\n\u001b[38;5;155mQuickDB to ST.db: \u001b[0mCopied successfully.\n")
    }
  }
  /**
   * @example db.transferDB(fileDB)
   * @param fileDB
   * @returns 
   */
  transferDB(fileDB) {
   if(fileDB.path){
       fileDB = fileDB.path
    }
    let filedata = fileDB.all()
    let olddata = this.load()
    fileDB.overwrite(olddata)
    fs.writeFileSync(this.db, JSON.stringify(filedata, null, 4))
    if (this.log === true) {
      console.log("\u001b[38;5;116mST.db: \u001b[0mCopied successfully.")
    }
  }
  /**
   * @example db.size(`kb`)
   * @param type
   * @returns 
   */
  size(type) {
   if(type.key){
       type = type.key
    }
    var stats = fs.statSync(`./${this.dbName}`)
    var fileSizeInBytes = stats.size;
    if (type === `KB` || type === `kb`) {
      var fileSizeInMegabytes = fileSizeInBytes / (1024);
      return fileSizeInMegabytes
    }
    if (type === `MB` || type === `mb`) {
      var fileSizeInMegabytes = fileSizeInBytes / (1024 * 1024);
      return fileSizeInMegabytes
    }
    return fileSizeInBytes
  }
  /**
   * @example db.remove(`st.db`)
   * @param key
   * @returns 
   */
  remove(key) {
    if(key.key){
       key = key.key
    }
    let data = this.load()
    try {
      delete data[key]
    } catch (error) {
      error = null
    }
    this.overwrite(data)
  }
  /**
   * @example db.delete(`st.db`)
   * @param data
   * @returns 
   */
  delete(data) {
    if(data.key){
       data = data.key
    }
    this.remove(data)
  }
  /**
   * @example db.deleteEach(`st.db`)
   * @param data
   * @returns 
   */
  deleteEach(data) {
    if(data.key){
      data = data.key
    }
    if (!data) throw Error("ST.db - No data to deleteEach")
    let fileData = this.load()
    let item = Object.keys(fileData)
    if (item === '') throw Error(nothingToDeleteeach)
    item = item.filter((Data) => Data.includes(data));
    item.forEach((Data) => {
      this.remove(Data)
    });
    return;
  }
  /**
   * @example db.load()
   * @returns 
   */
  load() {
    let data;
    try {
      data = JSON.parse(fs.readFileSync(this.db))
    } catch (error) {
      if (error) {
        data = JSON.parse("{}")
      }
    }

    return data;
  }
  /**
   * @example db.overwrite(`data`)
   * @param data
   * @returns 
   */
  overwrite(data) {
    fs.writeFileSync(this.db, JSON.stringify(data, null, 4))
  }
  /**
   * @example db.clear()
   * @returns 
   */
  clear() {
    let data = Object()
    this.overwrite(data)
  }
  /**
   * @example db.add(`data`,2)
   * @param key
   * @param value
   * @returns 
   */
  add(key, value) {
    if(key.key && key.value){
       value = key.value
       key = key.key
    }
    return this.math(key, "+", value);
  }
  /**
   * @example db.multiply(`data`, 5)
   * @param key
   * @param value
   * @returns 
   */
  multiply(key, value) {
    if(key.key && key.value){
       value = key.value
       key = key.key
    }
    return this.math(key, "*", value);
  }
  /**
   * @example db.multiply(`data`, 5)
   * @param key
   * @returns 
   */
  double(key) {
    if(key.key){
       key = key.key
    }
    return this.math(key, "*", 2);
  }
  /**
   * @example db.subtract(`data`,5)
   * @param data
   * @returns 
   */
  subtract(key, value) {
    if(key.key && key.value){
       value = key.value
       key = key.key
    }
    return this.math(key, "-", value);
  }
  valuesAll() {
    const all = this.all();
    return all.map((element) => element.data);
  }
  keysAll() {
    const all = this.all();
    return all.map((element) => element.ID);
  }
  /**
   * @example db.setDecrypt(`data`)
   * @param key
   * @param value
   * @returns 
   */
  setDecrypt(key = String(), value) {
    if (!value) throw Error("ST.db - You must enter a value to write in the data");
    let data = this.load()
    data[key] = value
    this.overwrite(data)
    if (this.log === true) return console.log(`\u001b[38;5;2m✚ \u001b[0m"${key}":"${value}" \u001b[38;5;2mhas been added in data\u001b[0m`);
  }
  /**
   * @example db.push(`st.db`,`data`)
   * @param key
   * @param value
   * @returns 
   */
  push(key, value) {
    if(key.key && key.value){
       value = key.value
       key = key.key
    }
    if (!value) throw Error("ST.db - No value to push to the array")
    let data = this.get(key);
    if (!data) {
      return this.setDecrypt(key, [value]);
    }
    if (Array.isArray(data)) {
      data.push(value);
      return this.setDecrypt(key, data);
    } else {
      return this.setDecrypt(key, [value]);
    }
  }
  /**
   * @example db.unshift(`st.db`,`data`)
   * @param key
   * @param value
   * @returns 
   */
  unshift(key, value) {
    if(key.key && key.value){
       value = key.value
       key = key.key
    }
    if (!value) throw Error("ST.db - No value to push to the array")
    let data = this.get(key);
    if (!data) {
      return this.setDecrypt(key, [value]);
    }
    if (Array.isArray(data)) {
      data.unshift(value);
      return this.setDecrypt(key, data);
    } else {
      return this.setDecrypt(key, [value]);
    }
  }
  /**
   * @example db.pop(`st.db`)
   * @param key
   * @returns 
   */
  pop(key) {
    if(key.key){
       key = key.key
    }
    let data = this.get(key);
    if (!data) {
      return this.setDecrypt(key, []);
    }
    if (Array.isArray(data)) {
      data.pop();
      return this.setDecrypt(key, data);
    } else {
      return this.setDecrypt(key, []);
    }
  }
  /**
   * @example db.shift(`st.db`)
   * @param key
   * @returns 
   */
  shift(key) {
    if(key.key){
       key = key.key
    }
    let data = this.get(key);
    if (!data) {
      return this.setDecrypt(key, []);
    }
    if (Array.isArray(data)) {
      data.shift();
      return this.setDecrypt(key, data);
    } else {
      return this.setDecrypt(key, []);
    }
  }
  /**
   * @example db.info
   * @returns 
   */
  info() {
    return {
      size: this.size(),
      version: "beta"
    };
  }
  /**
   * @example db.unpush(`st.db`,`data`)
   * @param db
   * @param data
   * @returns 
   */
  unpush(db, data) {
    if(key.key && key.value){
       data = key.value
       db = key.key
    }
    if (!db) throw Error("ST.db - No array fetch")
    if (!data) throw Error("ST.db - There is no data to execute on it")
    var arr = [];
    if (this.get(db)) {
      arr = this.get(db);
    }
    arr = arr.filter((x) => x !== data);
    this.setDecrypt(db, arr);
  }
  /**
   * @example db.type(`st.db`)
   * @param key
   * @returns 
   */
  type(key) {
    if(key.key){
       key = key.key
    }
    const data = this.get(key);
    if (Array.isArray(data) || data instanceof Array) return "array";
    else return typeof data;
  }
  /**
   * @example db.math(`st.db`,`+`,1)
   * @param key
   * @param operator
   * @param value
   * @param goToNegative
   * @returns 
   */
  math(key = String(), operator, value, goToNegative = false) {
    if(key.key && key.operator && key.value){
     value = key.value
     operator = key.operator
     goToNegative = key.goToNegative || false
     key = key.key
    }
    console.log(value)
    if (isNumber(value) == false) throw Error(`ST.db - The type of value is not a number.`);
    if (value <= 0) throw Error(`ST.db - Value cannot be less than 1`);
    value = Number(value);
    if (typeof goToNegative !== "boolean") throw Error(`ST.db - The goToNegative parameter must be of boolean type.`);
    let data = this.get(key);
    if (data <= 0) throw Error(`ST.db - Value cannot be less than 1`);
    if (!data) {
      return this.set(key, value);
    }
    if (typeof data !== "number") throw Error(`ST.db - ${key} ID data is not a number type data.`);
    data = Number(data);
    switch (operator) {
      case "+":
        data += value;
        return this.set(key, data);
        break;
      case "-":
        data -= value;
        if (goToNegative === false && data < 1) data = 0;
        return this.set(key, data);
        break;
      case "*":
        data *= value;
        return this.set(key, data);
        break;
      case "x":
        data *= value;
        return this.set(key, data);
        break;
      case "/":
        data /= value;
        return this.set(key, data);
        break;
      case "%":
        data %= value;
        return this.set(key, data);
        break;
      default:
        return undefined;
        break;
    }
  }
  /**
   * @example db.arrayFetch('st.db',1)
   * @param array
   * @param number
   * @returns 
   */
  arrayFetch(array, number) {
    if(array.array && array.length){
       number = array.length
       array = array.array
    }
    let fileData = this.load()
    if (!array) throw Error("ST.db - No array to array fetch")
    if (!number && number != 0) throw Error("ST.db - No   index/number to array fetch")
    if (!fileData[array] && !Array.isArray(fileData[array])) throw Error("ST.db - The array to fetch dosen't exist or it's not array")
    if (typeof number !== "number" && value !== 0) throw Error(`ST.db - The number/index to array fetch must be a number, received type: ${typeof value}`);
    if (!fileData[array][number]) fileData[array][number] = null
    return fileData[array][number];
  }
  /**
   * @example db.objectFetch('st.db',`data`)
   * @param object
   * @param key
   * @returns 
   */
  objectFetch(object, key) {
    if(object.object && object.key){
      key = object.key
      object = object.object
    }
    let fileData = this.load()
    if (!object) throw Error("ST.db - No object to object fetch")
    if (!key) throw Error("ST.db - No key to object fetch")
    if (!fileData[object]) throw Error("ST.db - The object to object fetch dosen't exist in the database");
    if (typeof fileData[object] !== 'object') throw Error("ST.db - The provided object to object fetch is not an object in the database");
    if (!fileData[object][key]) fileData[object][key] = null
    return fileData[object][key]
  }
}


// Copyright 2021, ST.db
module.exports = Data